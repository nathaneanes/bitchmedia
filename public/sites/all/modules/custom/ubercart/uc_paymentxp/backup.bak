<?php
// $Id: uc_paymentxp.module,v 1.2.2.3 2009/05/21 17:44:47 rszrama Exp $

/**
 * @file
 * Accept ACH and Credit Card payments using the paymentXP.com gateway.
 */
define('UC_PAYMENTXP_TEST_MERCHANTID', '10012');
define('UC_PAYMENTXP_TEST_MERCHANTKEY', 'C22A63EE-2E7A-4ACE-96AC-0958DC8D953F');
define('UC_PAYMENTXP_GATEWAY_URL', 'https://webservice.paymentxp.com/wh/WebHost.aspx');


/**
 * Implementation of hook_menu().
 */
function uc_paymentxp_menu() {
  $items = array();

  $items['admin/store/orders/%uc_order/paymentxp_ach'] = array(
    'title callback' => 'uc_paymentxp_ach_terminal_title',
    'title arguments' => array(3),
    'description' => 'Displays a form to process an eCheck payment.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('uc_paymentxp_ach_terminal_form', 3),
    'access arguments' => array('process paymentxp_ach payments'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

// Set the title for the paymentXP terminal.
function uc_paymentxp_ach_terminal_title($order) {
  return t('paymentXP ACH terminal: Order @order_id', array('@order_id' => $order->order_id));
}

/**
 * Implementation of hook_perm().
 */
function uc_paymentxp_perm() {
  return array('process paymentxp_ach payments');
}

/**
 * Implementation of hook_cron().
 */
function uc_paymentxp_cron() {
  // Delete any ACH data that's been stagnant for 15 minutes or more.
  db_query("DELETE FROM {uc_payment_paymentxp_ach} WHERE order_id IN(SELECT order_id FROM {uc_orders} WHERE order_status IN". uc_order_status_list('specific', TRUE) ." AND modified <= %d)", time() - variable_get('uc_paymentxp_ach_wipe_interval', 900));
}

/**
 * Implementation of hook_form_alter().
 */
function uc_paymentxp_form_alter(&$form, &$form_state, $form_id) {
  switch ($form_id) {
    case 'uc_payment_gateways_form':
      if (empty($_POST) && uc_paymentxp_ach_encryption_key() === FALSE) {
        drupal_set_message(t('The paymentXP ACH encryption key filepath must be configured to accept ACH payments.'), 'error');
      }
      $form['#validate'][] = 'uc_paymentxp_settings_form_validate';
      $form['#submit'][] = 'uc_paymentxp_settings_form_submit';
      break;

  }
}

/**
 * Implementation of hook_payment_gateway().
 */
function uc_paymentxp_payment_gateway() {
  $gateways[] = array(
    'id' => 'paymentxp_credit',
    'title' => t('paymentXP.com'),
    'description' => t('Process credit card payments using the credit card gateway at paymentXP.com'),
    'settings' => 'uc_paymentxp_settings_form',
    'credit' => 'uc_paymentxp_credit_charge',
    'credit_txn_types' => array(UC_CREDIT_AUTH_CAPTURE, UC_CREDIT_REFERENCE_SET, UC_CREDIT_REFERENCE_TXN),
  );

  return $gateways;
}

/**
 * Callback for payment gateway settings.
 */
function uc_paymentxp_settings_form() {
  $form['api_id_key'] = array(
    '#type' => 'fieldset',
    '#title' => t('PaymentXP API Merchant ID and Key'),
    '#description' => t('This information is required for Ubercart to interact with the PaymentXP gateway.'),
  );
  $form['api_id_key']['uc_paymentxp_merchant_id'] = array(
    '#type' => 'textfield',
    '#title' => t('PaymentXP Merchant ID'),
    '#default_value' => variable_get('uc_paymentxp_merchant_id', ''),
  );
  $form['api_id_key']['uc_paymentxp_merchant_key'] = array(
    '#type' => 'textfield',
    '#title' => t('PaymentXP Merchant Key'),
    '#default_value' => variable_get('uc_paymentxp_merchant_key', ''),
  );

  $form['settings'] = array(
    '#type' => 'fieldset',
    '#title' => t('Mode/Settings'),
    '#description' => t('This allows you to set settings for the securepay account you are accessing.'),
  );
 
  $account_types = array(
      'live' => t('Live transactions in a live account'),
      'test' => t('Developer test account transactions'),
  );
 $form['settings']['uc_paymentxp_txn_mode'] = array(
    '#type' => 'select',
    '#title' => t('Live/Test account'),
    '#description' => t('Set to use the live or test account settings at PaymentXP'),
    '#options' => $account_types,
    '#default_value' => variable_get('uc_paymentxp_txn_mode', 'test'),
  );
  $form['settings']['uc_paymentxp_response_debug'] = array(
    '#type' => 'checkbox',
    '#title' => t('Log full API response messages from PaymentXP for debugging.'),
    '#default_value' => variable_get('uc_paymentxp_response_debug', FALSE),
  );
  $form['security'] = array(
    '#type' => 'fieldset',
    '#title' => t('Account number security'),
  );
  $form['security']['uc_paymentxp_ach_encryption_path'] = array(
    '#type' => 'textfield',
    '#title' => t('Account number encryption key filepath'),
    '#description' => t('<b>You must enable encryption</b> by following the <a href="!url">encryption instructions</a> in order to protect customer bank account data.<br />In short, you should specify a path outside of your document root where the encryption key may be stored.<br />Relative paths will be resolved relative to the Drupal installation directory.<br />Once this is set, you should not change it.', array('!url' => 'http://www.ubercart.org/docs/user/2731/credit_card_settings#security')),
    '#default_value' => variable_get('uc_paymentxp_ach_encryption_path', t('Not configured, see below.')),
  );
  $form['security']['uc_paymentxp_ach_acct_num_mask'] = array(
    '#type' => 'textfield',
    '#title' => t('Account number mask'),
    '#description' => t('To protect bank account numbers, the last 4 digits will be displayed after this mask when they are shown to the user.'),
    '#default_value' => variable_get('uc_paymentxp_ach_acct_num_mask', 'xxxxxx'),
  );
  $form['security']['uc_paymentxp_ach_wipe_interval'] = array(
    '#type' => 'select',
    '#title' => t('Data wipe interval'),
    '#description' => t('ACH data will be wiped on inactive orders that are canceled or never make it through checkout after this interval of time passes.'),
    '#options' => array(
      300 => t('5 minutes'),
      600 => t('10 minutes'),
      900 => t('15 minutes'),
      1200 => t('20 minutes'),
      1500 => t('25 minutes'),
      1800 => t('30 minutes'),
      2700 => t('45 minutes'),
      3600 => t('1 hour'),
      7200 => t('2 hours'),
      14400 => t('4 hours'),
      28800 => t('8 hours'),
      57600 => t('16 hours'),
      86400 => t('1 day'),
    ),
    '#default_value' => variable_get('uc_paymentxp_ach_wipe_interval', 900),
  );

  return $form;
}



// Makes sure the encryption key directory in the paymentXP ACH settings is valid.
function uc_paymentxp_settings_form_validate($form, &$form_state) {
  $dir = variable_get('uc_paymentxp_ach_encryption_path', t('Not configured, see below.'));
  $filename = rtrim($dir, '/\\') .'/uc_paymentxp_ach.key';

  if ($form_state['values']['uc_paymentxp_ach_encryption_path'] !== variable_get('uc_paymentxp_ach_encryption_path', t('Not configured, see below.'))) {
    $dir = rtrim($form_state['values']['uc_paymentxp_ach_encryption_path'], '/\\');

    $_SESSION['update_paymentxp_ach_encrypt_dir'] = TRUE;
    if (!empty($dir) && $dir !== t('Not configured, see below.')) {
      if (!is_dir($dir)) {
        form_set_error('uc_paymentxp_ach_encryption_path', t('You have specified a non-existent directory.'));
        unset($_SESSION['update_paymentxp_ach_encrypt_dir']);
      }
      else {
        $file = fopen($dir .'/encrypt.test', 'w');
        if ($file === FALSE) {
          form_set_error('uc_paymentxp_ach_encryption_path', t('Cannot write to directory, please verify the directory permissions.'));
          unset($_SESSION['update_paymentxp_ach_encrypt_dir']);
        }
        else {
          if (fwrite($file, '0123456789') === FALSE) {
            form_set_error('uc_paymentxp_ach_encryption_path', t('Cannot write to directory, please verify the directory permissions.'));
            unset($_SESSION['update_paymentxp_ach_encrypt_dir']);
            fclose($file);
          }
          else {
            fclose($file);
            $file = fopen($dir .'/encrypt.test', 'r');
            if ($file === FALSE) {
              form_set_error('uc_paymentxp_ach_encryption_path', t('Cannot read from directory, please verify the directory permissions.'));
              unset($_SESSION['update_paymentxp_ach_encrypt_dir']);
            }
            fclose($file);
          }
          unlink($dir .'/encrypt.test');
        }
      }
    }
  }
}

// Creates the encryption key file if it doesn't already exist.
function uc_paymentxp_settings_form_submit($form, &$form_state) {
  if ($_SESSION['update_paymentxp_ach_encrypt_dir'] === TRUE) {
    $dir = rtrim($form_state['values']['uc_paymentxp_ach_encryption_path'], '/\\');

    if (!empty($dir) && $dir !== t('Not configured, see below.')) {
      if (!file_exists($dir .'/uc_paymentxp_ach.key')) {
        if (!$file = fopen($dir .'/uc_paymentxp_ach.key', 'wb')) {
          $message = t('paymentXP ACH encryption key file creation failed. Check your filepath settings and directory permissions.');
          drupal_set_message($message, 'error');
          watchdog('payment_xp', $message, WATCHDOG_ERROR);
        }
        else {
          // Replacement key generation suggested by Barry Jaspan for increased security.
          fwrite($file, md5(drupal_get_token(serialize($_REQUEST) . serialize($_SERVER) . time())));
          fclose($file);

          drupal_set_message(t('paymentXP ACH encryption key file generated. ACH data will now be encrypted.'));
          watchdog('uc_paymentxp_ach', 'paymentXP ACH encryption key file generated.');
        }
      }
    }
  }
}





/**
 * Implementation of hook_store_status().
 */
function uc_paymentxp_store_status() {
  // Throw up an error row if encryption has not been set up yet.
  if ($key = uc_paymentxp_ach_encryption_key()) {
    $statuses[] = array(
      'status' => 'ok',
      'title' => t('paymentXP ACH encryption'),
      'desc' => t('ACH data is encrypted during checkout for maximum security.'),
    );
  }
  else {
    $statuses[] = array(
      'status' => 'error',
      'title' => t('paymentXP ACH encryption'),
      'desc' => t('You must review your <a href="!url">paymentXP ACH security settings</a> and enable encryption before you can accept ACH payments.', array('!url' => url('admin/store/settings/payment/edit/methods'))),
    );
  }

  return $statuses;
}

/**
 * Implementation of hook_order().
 */
function uc_paymentxp_order($op, &$arg1, $arg2) {
  // If the order payment method is paymentXP ACH...
  if ($arg1->payment_method == 'paymentxp_ach') {
    switch ($op) {
      // Attempt payment upon order submission during checkout.
      case 'submit':
        // Process the ACH payment.
       
        $result = uc_paymentxp_ach_charge($arg1, $arg1->order_total);
      
        // If the payment failed, halt the checkout process.
        if ($result !== TRUE) {
          return array(array('pass' => FALSE, 'message' => $result));
        }
        
        break;

      case 'save':
        // Save the ACH data for the order.
        uc_paymentxp_save_paymentxp_ach($arg1);
        break;

      case 'load':
        // Load the ACH data for the order.
        $arg1->payment_details = uc_paymentxp_load_paymentxp_ach($arg1);
        break;
    }
  }
}

/**
 * Implementation of hook_payment_method().
 */
function uc_paymentxp_payment_method() {
  $methods = array();

  // Do not show the ACH payment method if encryption is not configured.
  if (arg(1) == 'checkout' && uc_paymentxp_ach_encryption_key() === FALSE) {
    return;
  }

  $methods[] = array(
    'id' => 'paymentxp_ach',
    'name' => arg(1) == 'checkout' ? t('ACH') : t('paymentXP ACH'),
    'title' => t('eCheck'),
    'desc' => t('Pay by Electronic Check using your bank account information.'),
    'callback' => 'uc_payment_method_paymentxp_ach',
    'weight' => 1,
    'checkout' => TRUE,
    'no_gateway' => TRUE,
  );

  return $methods;
}

// Callback function for the paymentXP ach payment method.
function uc_payment_method_paymentxp_ach($op, &$arg1, $silent = FALSE) {
  switch ($op) {
    case 'cart-details':
      return uc_strip_form(drupal_get_form('uc_paymentxp_ach_payment_form', $arg1));

    case 'cart-process':
      // Fetch the paymentXP ACH details from the $_POST directly.
      $data = array(
        'paymentxp_bank_name' => check_plain($_POST['paymentxp_bank_name']),
        'paymentxp_bank_aba_code' => check_plain(str_replace(' ', '',  $_POST['paymentxp_bank_aba_code'])),
        'paymentxp_bank_acct_num' => check_plain(str_replace(' ', '', $_POST['paymentxp_bank_acct_num'])),
        'paymentxp_bank_acct_name' => check_plain($_POST['paymentxp_bank_acct_name']),
        'paymentxp_bank_acct_type' => check_plain($_POST['paymentxp_bank_acct_type']),
      );

      // Go ahead and put the eCheck data in the payment details array.
      $arg1->payment_details = $data;

      // Default our value for validation.
      $return = TRUE;

      // Make sure a bank name was entered.
      if (empty($data['paymentxp_bank_name'])) {
        if (!$silent) {
          drupal_set_message(t('You must enter the name of your bank.'), 'error');
        }
        $return = FALSE;
      }

      // Validate the bank routing number.
      if (empty($data['paymentxp_bank_aba_code']) || !ctype_digit($data['paymentxp_bank_aba_code'])) {
        if (!$silent) {
          drupal_set_message(t('You must enter a valid bank routing number.'), 'error');
        }
        $return = FALSE;
      }

      // Validate the bank account number.
      if (empty($data['paymentxp_bank_acct_num']) || !ctype_digit($data['paymentxp_bank_acct_num'])) {
        if (!$silent) {
          drupal_set_message(t('You must enter a valid bank account number.'), 'error');
        }
        $return = FALSE;
      }

      // Make sure an account name was entered.
      if (empty($data['paymentxp_bank_acct_name'])) {
        if (!$silent) {
          drupal_set_message(t('You must enter the name associated with your bank account.'), 'error');
        }
        $return = FALSE;
      }

      return $return;

    case 'cart-review':
      $review = array();

      $review[] = array('title' => t('Bank'), 'data' => check_plain($arg1->payment_details['paymentxp_bank_name']));
      $review[] = array('title' => t('Routing number'), 'data' => check_plain($arg1->payment_details['paymentxp_bank_aba_code']));
      $review[] = array('title' => t('Account number'), 'data' => check_plain(variable_get('uc_paymentxp_acct_num_mask', 'xxxxxx') . $arg1->payment_details['paymentxp_bank_acct_num_last4']));
      $review[] = array('title' => t('Account name'), 'data' => check_plain($arg1->payment_details['paymentxp_bank_acct_name']));
      $review[] = array('title' => t('Account type'), 'data' => uc_paymentxp_ach_acct_type($arg1->payment_details['paymentxp_bank_acct_type']));

      return $review;

    case 'order-view':
    case 'customer-view':
      $lines = array(
        t('Bank name') .': '. check_plain($arg1->payment_details['paymentxp_bank_name']),
        t('Account #') .': '. check_plain(variable_get('uc_paymentxp_acct_num_mask', 'xxxxxx') . $arg1->payment_details['paymentxp_bank_acct_num_last4']),
      );

      if ($op == 'order-view' && user_access('process paymentxp_ach payments')) {
        $lines[] = l(t('Process eCheck payment.'), 'admin/store/orders/'. $arg1->order_id .'/paymentxp_ach');
      }

      return implode('<br />', $lines);

    case 'order-details':
      if (user_access('process paymentxp_ach payments')) {
        return t('Process paymentXP ACH payments using the<br />terminal available through the view tab.');
      }
      else {
        return t('Processing paymentXP ACH payments requires<br />appropriate admin permission.');
      }

    
  }
}

// Form to gather the required fields to process an ACH payment.
function uc_paymentxp_ach_payment_form($form_state, $order) {
  $form = array();
  ///XXX  Debugging to make my life easier
  $order->payment_details['paymentxp_bank_name'] = 'Wells Fargo';
  $order->payment_details['paymentxp_bank_aba_code'] = '123006800';
  $order->payment_details['paymentxp_bank_acct_num'] = '0635560071';
  $order->payment_details['paymentxp_bank_acct_name'] = 'Ryan Aslett';
  $order->payment_details['paymentxp_bank_acct_type'] = 'Checking';
      
  $form['paymentxp_bank_name'] = array(
    '#type' => 'textfield',
    '#title' => t('Bank name'),
    '#default_value' => $order->payment_details['paymentxp_bank_name'],
    '#attributes' => array('autocomplete' => 'off'),
    '#required' => TRUE,
    '#maxlength' => 50,
    '#size' => 32,
  );
  $form['paymentxp_bank_aba_code'] = array(
    '#type' => 'textfield',
    '#title' => t('Bank routing number'),
    '#description' => t('The first 9 digit number along the bottom of your checks.'),
    '#default_value' => $order->payment_details['paymentxp_bank_aba_code'],
    '#attributes' => array('autocomplete' => 'off'),
    '#required' => TRUE,
    '#maxlength' => 9,
    '#size' => 32,
  );
  $form['paymentxp_bank_acct_num'] = array(
    '#type' => 'textfield',
    '#title' => t('Bank account number'),
    '#description' => t('Up to a 20 digit number next to the the routing number.'),
    '#default_value' => $order->payment_details['paymentxp_bank_acct_num'],
    '#attributes' => array('autocomplete' => 'off'),
    '#required' => TRUE,
    '#maxlength' => 20,
    '#size' => 32,
  );
  $form['paymentxp_bank_acct_name'] = array(
    '#type' => 'textfield',
    '#title' => t('Name on the account'),
    '#default_value' => $order->payment_details['paymentxp_bank_acct_name'],
    '#attributes' => array('autocomplete' => 'off'),
    '#required' => TRUE,
    '#maxlength' => 50,
    '#size' => 32,
  );
  $form['paymentxp_bank_acct_type'] = array(
    '#type' => 'select',
    '#title' => t('Bank account type'),
    '#options' => uc_paymentxp_ach_acct_type(),
    '#default_value' => !empty($order->payment_details['paymentxp_bank_acct_type']) ? $order->payment_details['paymentxp_bank_acct_type'] : 'CHECKING',
    '#required' => TRUE,
  );

  return $form;
}

/**
 * Loads the key for bank account number encryption from a file.
 *
 * @return
 *   The encryption key or FALSE if it can't be found.
 */
function uc_paymentxp_ach_encryption_key() {
  static $key;

  if (!empty($key)) {
    return $key;
  }

  $dir = variable_get('uc_paymentxp_ach_encryption_path', t('Not configured, see below.'));

  if (!empty($dir) && $dir !== t('Not configured, see below.')) {
    $filename = rtrim($dir, '/\\') .'/uc_paymentxp_ach.key';

    if (file_exists($filename)) {
      if (!$file = fopen($filename, 'r')) {
        return FALSE;
      }

      $key = fread($file, filesize($filename));
      fclose($file);
    }
  }
  else {
    return FALSE;
  }

  return $key;
}
/*
 * Main payment methods under here. _charge is for cc data, _ach_process is the echeck portion
 */


/**
 * Main handler for processing credit card transactions.
 */
function uc_paymentxp_credit_charge($order_id, $amount, $data) {
  // load the order object
  $order = uc_order_load($order_id);

  // Perform the appropriate action based on the transaction type.
  switch ($data['txn_type']) {
    // Accommodate all other transaction types.
      
    case UC_CREDIT_REFERENCE_SET:
      break;
    case UC_CREDIT_REFERENCE_TXN:
      break;
    case UC_CREDIT_AUTH_CAPTURE:
    default:
      return _uc_paymentxp_credit_charge($order, $amount, $data);
  }
}

function _uc_paymentxp_credit_charge($order, $amount, $data){
  global $user;

  // Build a description of the order for logging in Auth.Net.
  $description = array();
  foreach ((array) $order->products as $product) {
    $description[] = $product->qty .'x '. $product->model;
  }

  $billing_country = uc_get_country_data(array('country_id' => $order->billing_country));
  $delivery_country = uc_get_country_data(array('country_id' => $order->delivery_country));

  $context = array(
    'revision' => 'formatted-original',
    'type' => 'amount',
  );
  $options = array(
    'sign' => FALSE,
    'thou' => FALSE,
    'dec' => '.',
  );
  if ($order->payment_details['cc_exp_month'] < 10) {
      $expiration_date = '0'. $order->payment_details['cc_exp_month'];
    } else {
      $expiration_date = $order->payment_details['cc_exp_month'];
    }
    
    $expiration_date .= substr($order->payment_details['cc_exp_year'], 2, 2);
  // Build the POST data for the transaction.
  $submit_data = array(
  
    'TransactionType' => 'CreditCardCharge',
    // Card Details
    'CardNumber' => $order->payment_details['cc_number'],
    'ExpirationDateMMYY' => $expiration_date,
    'CVV2' => $order->payment_details['cc_cvv'],   
 
    // Order Information
    'ReferenceNumber' => $order->order_id,
    'TransactionAmount' => uc_price($amount, $context, $options),
    'ClerkID' => 'Website',
    'CustomInfo2' => substr(implode(', ', $description), 0, 50),
    'CustomInfo3' => substr(implode(', ', $description), 50, 50),
  
    // Customer Information
    'CustomInfo1' => 'UserID: ' . substr($order->uid, 0, 50),
    'EmailAddress' => substr($order->primary_email, 0, 50),
    'ClientIPAddress' => substr(ip_address(), 0, 25),
    
    // Customer Address
    'BillingNameFirst' => substr($order->billing_first_name, 0, 50),
    'BillingNameLast' => substr($order->billing_last_name, 0, 50),
    'BillingFullName' => substr($order->billing_first_name . ' ' . $order->billing_last_name, 0, 50),
    'BillingAddress' => substr($order->billing_street1, 0, 50),
    'BillingCity' => substr($order->billing_city, 0, 50),
    'BillingState' => substr(uc_get_zone_code($order->billing_zone), 0, 25),
    'BillingZipCode' => substr($order->billing_postal_code, 0, 10),
    
    'BillingCountry' => !$billing_country ? '' : $billing_country[0]['country_name'],
    'PhoneNumber' => substr($order->billing_phone, 0, 10),
    // Shipping Information - might be useless, dont see how to get them from the interface
    'ShippingAddress1' => substr($order->delivery_street1, 0, 50),
    'ShippingAddress2' => substr($order->delivery_street2, 0, 50),
    'ShippingCity' => substr($order->delivery_city, 0, 50),
    'ShippingState' => substr(uc_get_zone_code($order->delivery_zone), 0, 25),
    'ShippingZipCode' => substr($order->delivery_postal_code, 0, 10),
    'ShippingCountry' => !$delivery_country ? '' : $delivery_country[0]['country_name'],

   );
   //TODO: Add later for AUTH transactions
//  if ($data['txn_type'] == UC_CREDIT_PRIOR_AUTH_CAPTURE) {
//    $submit_data['x_trans_id'] = $data['auth_id'];
//  }
  
  $response = _uc_paymentxp_post_gateway_transaction($submit_data);

  if (variable_get('uc_paymentxp_response_debug', FALSE)) {
    watchdog('uc_paymentxp', 'Debug response: !data', array('!data' => '<pre>'. check_plain(print_r($response, TRUE)) .'</pre>'));
  }

  // If we didn't get an approval response code...
  if ($response['StatusID'] != '0') {
    // Fail the charge with the reason text in the decline message.
    $result = array(
      'success' => FALSE,
      'message' => t('Credit card payment declined: @message', array('@message' => $response['ResponseMessage'])),
      'uid' => $user->uid,
    );
  }
  else {
    // Build a message for display and comments in the payments table.
    $message = t('PaymentXP TransactionID: @id<br />Messages: @response', array('@id' => $response['TransactionID'],'@response' => $response['ResponseMessage']));
    $result = array(
      'success' => TRUE,
      'comment' => $message,
      'message' => $message,
      'data' => array('module' => 'uc_paymentxp', 'txn_id' => $response['TransactionID']),
      'uid' => $user->uid,
    );

    //TODO: add these later to support the in cart terminal
//    // If this was an authorization only transaction...
//    if ($data['txn_type'] == UC_CREDIT_AUTH_ONLY) {
//      // Log the authorization to the order.
//      uc_credit_log_authorization($order->order_id, $response[6], $amount);
//    }
//    elseif ($data['txn_type'] == UC_CREDIT_PRIOR_AUTH_CAPTURE) {
//      uc_credit_log_prior_auth_capture($order->order_id, $data['auth_id']);
//    }

    // Create a transaction reference if specified in the payment gateway
    // settings and this is an appropriate transaction type.
    //TODO: Save the users profile data with AddCustomer(), but only if they are logged in.
    //Otherwise save the order to the cache and add their profile data after an account is created.
//    if (variable_get('uc_authnet_cim_profile', FALSE) && in_array($data['txn_type'], array(UC_CREDIT_AUTH_ONLY, UC_CREDIT_AUTH_CAPTURE))) {
//      // Ignore the returned message for now; that will appear in the comments.
//      _uc_authorizenet_cim_profile_create($order);
//    }
    if ($order->uid){
      //Save the user as a customer
      $response = _uc_paymentxp_customer_vault($order, 'credit');

      if (!$response['success']){
        //Saving the profile failed for some reason. Bubble up the exception.
        return $response;
      }

    }
    else {
      //encrypt the payment details in the session so we can access it after the user has been saved
      //This will allow us to create a customer record at paymentXP after we have a valid userid for
      //Anonymous users.
      $thing = db_query("SELECT uid FROM {users} WHERE mail = '%s'", $order->primary_email);

      // If it was found, update the order.
      if ($account = db_fetch_object($thing)) {
        $order->uid = $account->uid;
        //Save the user as a customer
        $vault_response = _uc_paymentxp_customer_vault($order, 'credit');

      }    
      uc_paymentxp_cache($order->payment_details);
        
    }
  }

  // Don't log this as a payment money wasn't actually captured.
//  if (in_array($data['txn_type'], array(UC_CREDIT_AUTH_ONLY))) {
//    $result['log_payment'] = FALSE;
//  }

  // Build an admin order comment.
  $context = array(
    'revision' => 'formatted-original',
    'type' => 'amount',
  );
  $comment = t('<b>PaymentXP CC</b><br /><b>@status:</b> @message<br />Amount: @amount<br />AVS response: @avs',
    array('@status' => $result['success'] ? t('ACCEPTED') : t('REJECTED'), '@message' => $response['ResponseMessage'], '@amount' => uc_price($response['TransactionAmount'], $context), '@avs' => $response['AVSResponseMessage']));

  // Add the CVV response if enabled.
  if (variable_get('uc_credit_cvv_enabled', TRUE)) {
    $comment .= '<br />'. t('CVV match: @cvv', array('@cvv' => $response['CVV2ResponseMessage']));
  }

  // Save the comment to the order.
  uc_order_comment_save($order->order_id, $order->uid, $comment, 'admin');
  $order->data = uc_credit_log_reference($order->order_id, $order->uid, $order->payment_details['cc_number']);
  
  return $result; 
}

/**
 * Process a payment for an order for the amount specified, using stored banking information
 * Uses AddCustomerACHDebit()
 *
 * @param $order
 *   The fully loaded order object holding the ACH payment details.
 * @param $amount
 *   The amount to charge on the ACH.
 * @return
 *   TRUE if payment was successful or an error message if not.
 */

function uc_paymentxp_credit_customer_charge($order, $amount, $op = NULL) {
  // Build a description of the order for PaymentXP description field.
  $customer_id = _uc_paymentxp_get_customer_id($order->uid);
  
  $context = array(
    'revision' => 'formatted-original',
    'location' => 'paymentXP-credit-recurring-charge',
  );
  $options = array(
    'sign' => FALSE,
    'thou' => FALSE,
    'dec' => '.',
  );

  // Build the POST data for the transaction.
  $submit_data = array(    
    // Transaction Information
    'TransactionType' => 'AddCustomerCCCharge',
    'CustomerID' => substr($customer_id, 0, 50),
    'TransactionAmount' => substr(uc_price($amount, $context, $options),0,9),
    'ClientIPAddress' => substr(ip_address(), 0, 25),
    'ClerkID' => 'Website',
    'ReferenceNumber' => $order->order_id,
    'CustomInfo1' => substr(implode(', ', $description), 0, 50),
    'CustomInfo2' => substr(implode(', ', $description), 50, 50),
    'CustomInfo3' => substr(implode(', ', $description), 100, 50),
  );

 $response = _uc_paymentxp_post_gateway_transaction($submit_data);  
 
 if (variable_get('uc_paymentxp_response_debug', FALSE)) {
    watchdog('uc_paymentxp', 'Debug response: !data', array('!data' => '<pre>'. check_plain(print_r($response, TRUE)) .'</pre>'));
  }

  // If we didn't get an approval response code...
  if ($response['StatusID'] != '0') {
    // Fail the charge with the reason text in the decline message.
    $result = array(
      'success' => FALSE,
      'message' => t('Credit card payment declined: @message', array('@message' => $response['ResponseMessage'])),
      'uid' => $order->uid,
    );
  }
  else {
    // Build a message for display and comments in the payments table.
    $message = t('PaymentXP TransactionID: @id<br />Messages: @response', array('@id' => $response['TransactionID'],'@response' => $response['ResponseMessage']));
    $result = array(
      'success' => TRUE,
      'comment' => $message,
      'message' => $message,
      'data' => array('module' => 'uc_paymentxp', 'txn_id' => $response['TransactionID']),
      'uid' => $order->uid,
    );
  }
  // Build an admin order comment.
  $context = array(
    'revision' => 'formatted-original',
    'type' => 'amount',
  );
  $comment = t('<b>PaymentXP CC</b><br /><b>@status:</b> @message<br />Amount: @amount<br />AVS response: @avs',
    array('@status' => $result['success'] ? t('ACCEPTED') : t('REJECTED'), '@message' => $response['ResponseMessage'], '@amount' => uc_price($response['TransactionAmount'], $context), '@avs' => $response['AVSResponseMessage']));

  // Add the CVV response if enabled.
  if (variable_get('uc_credit_cvv_enabled', TRUE)) {
    $comment .= '<br />'. t('CVV match: @cvv', array('@cvv' => $response['CVV2ResponseMessage']));
  }

  // Save the comment to the order.
  uc_order_comment_save($order->order_id, $order->uid, $comment, 'admin');

  return $result;
}


/**
 * Process an ACH payment for an order for the amount specified. 
 * Uses ACHDebit()
 *
 * @param $order
 *   The fully loaded order object holding the ACH payment details.
 * @param $amount
 *   The amount to charge on the ACH.
 * @return
 *   TRUE if payment was successful or an error message if not.
 */

function uc_paymentxp_ach_charge($order, $amount) {
  
  $context = array(
    'revision' => 'formatted-original',
    'location' => 'paymentXP-ACH-charge',
  );
  $options = array(
    'sign' => FALSE,
    'thou' => FALSE,
    'dec' => '.',
  );
  // Build the POST data for the transaction.
  $submit_data = array(    
    // Transaction Information
    'TransactionType' => 'ACHDebit',
    'RoutingNumber' => substr($order->payment_details['paymentxp_bank_aba_code'], 0, 9),
    'AccountNumber' => substr($order->payment_details['paymentxp_bank_acct_num'], 0, 17),
    'BankAccountType' => $order->payment_details['paymentxp_bank_acct_type'],
    'AccountName' => substr($order->payment_details['paymentxp_bank_acct_name'],0,23),
    'Amount' => substr(uc_price($amount, $context, $options), 0,8),
 
    // Order Information
    'ReferenceNumber' => $order->order_id,
    'Description' => 'Bitchmedia',
    'ProcessDate' => date("mdY"),
    'ACHCheckType' => '1',
  
    // Customer Information
    'CheckNumber' => '',
   
    //We dont have a customer ID at this point for anonymous users..
    //'CustomerID' => substr($order->uid, 0, 20),
  );

  $response = _uc_paymentxp_post_gateway_transaction($submit_data);  
  switch ($response['StatusID']) {
     // Payment is declined.
    case '0':
      $result = array(
        'success' => FALSE,
        'message' => t('Payment declined: @message', array('@message' => $response['Message'])),
      );
      break;
    // Payment is accepted.
    case '1':
      $result = array(
        'success' => TRUE,
        'message' => t('Payment accepted. Transaction ID: @txn_id', array('@txn_id' => $response['Message'])),
      );
      break;
    // Error processing the transaction.
    case '2':
      $result = array(
        'success' => FALSE,
        'message' => t('Payment timed out: @message', array('@message' => $response['Message'])),
      );
      break;

    // Payment is under review.
    case '3':
      $result = array(
        'success' => FALSE,
        'message' => t('Payment canceled: @message', array('@message' => $response['Message'])),
      );
      break;
  }
  if (variable_get('uc_paymentxp_response_debug', FALSE)) {
    watchdog('uc_paymentxp', 'Debug response: !data', array('!data' => '<pre>'. check_plain(print_r($response, TRUE)) .'</pre>'));
  }

  // Build an admin order comment.
  $context = array(
    'revision' => 'formatted-original',
    'location' => 'paymentXP-ach-charge-comment',
  );
  $comment = t('<b>paymentXP</b><br />!message<br />Amount: !amount', array('!message' => $result['message'], '!amount' => uc_price($response['TransactionAmount'], $context)));

  // Save the comment to the order.
  uc_order_comment_save($order->order_id, $order->uid, $comment, 'admin');

  // Return TRUE for successful payments or the error message for failures.
  if ($result['success']) {
    // Enter the payment.
    uc_payment_enter($order->order_id, 'paymentxp_ach', $response['TransactionAmount'], $order->uid, '', t('Transaction ID: @txn_id', array('@txn_id' => $response['TransactionID'])));
    // Save the user
    if ($order->uid){
        //Save the user as a customer
        $response = _uc_paymentxp_customer_vault($order, 'paymentxp_ach');
        
       if (!$response['success']){
          //Saving the profile failed for some reason. Bubble up the exception.
          return $response['message'];
        }
        
      }
      else {
        $thing = db_query("SELECT uid FROM {users} WHERE mail = '%s'", $order->primary_email);

        // If it was found, update the order.
        if ($account = db_fetch_object($thing)) {
          $order->uid = $account->uid;
          //Save the user as a customer
          $vault_response = _uc_paymentxp_customer_vault($order, 'paymentxp_ach');
          
        }
        //encrypt the payment details in the session so we can access it after the user has been saved
        //This will allow us to create a customer record at paymentXP after we have a valid userid for
        //Anonymous users.
        uc_paymentxp_cache($order->payment_details);
      }
    return TRUE;
  }
  else {
    return $result['message'];
  }
}

/**
 * Process a payment for an order for the amount specified, using stored banking information
 * Uses AddCustomerACHDebit()
 *
 * @param $order
 *   The fully loaded order object holding the ACH payment details.
 * @param $amount
 *   The amount to charge on the ACH.
 * @return
 *   TRUE if payment was successful or an error message if not.
 */

function uc_paymentxp_ach_customer_charge($order, $amount, $op) {
  // Build a description of the order for PaymentXP description field.
  $customer_id = _uc_paymentxp_get_customer_id($order->uid);
  
  $context = array(
    'revision' => 'formatted-original',
    'location' => 'paymentXP-ACH-recurring-charge',
  );
  $options = array(
    'sign' => FALSE,
    'thou' => FALSE,
    'dec' => '.',
  );

  // Build the POST data for the transaction.
  $submit_data = array(    
    // Transaction Information
    'TransactionType' => 'AddCustomerACHDebit',
    'Amount' => uc_price($amount, $context, $options),
    // Order Information
    'ReferenceNumber' => $order->order_id,
    'Description' => 'Bitchmedia',
    'ProcessDate' => date("mdY"),
    'CustomerID' => substr($customer_id, 0, 50),
  );

 $response = _uc_paymentxp_post_gateway_transaction($submit_data);  
  switch ($response['StatusID']) {
     // Payment is declined.
    case '0':
      $result = array(
        'success' => FALSE,
        'message' => t('Payment declined: @message', array('@message' => $response['Message'])),
      );
      break;
    // Payment is accepted.
    case '1':
      $result = array(
        'success' => TRUE,
        'message' => t('Payment accepted. Transaction ID: @txn_id', array('@txn_id' => $response['Message'])),
      );
      break;
    // Payment timed out.
    case '2':
      $result = array(
        'success' => FALSE,
        'message' => t('Payment timed out: @message', array('@message' => $response['Message'])),
      );
      break;

    // Payment is canceled.
    case '3':
      $result = array(
        'success' => FALSE,
        'message' => t('Payment canceled: @message', array('@message' => $response['Message'])),
      );
      break;
  }

  // Build an admin order comment.
  $context = array(
    'revision' => 'formatted-original',
    'location' => 'paymentXP-ach-stored-charge-comment',
  );
  $comment = t('<b>paymentXP</b><br />!message<br />Amount: !amount', array('!message' => $result['message'], '!amount' => uc_price($response['TransactionAmount'], $context)));

  // Save the comment to the order.
  uc_order_comment_save($order->order_id, $order->uid, $comment, 'admin');

  // Return TRUE for successful payments or the error message for failures.
  if ($result['success']) {
    // Enter the payment.
    uc_payment_enter($order->order_id, 'paymentxp_ach', $response['TransactionAmount'], $order->uid, '', t('Transaction ID: @txn_id', array('@txn_id' => $response['TransactionID'])));

    return TRUE;
  }
  else {
    return $result['message'];
  }
}
/*
 * Gets a customer id depending upon the txn mode of test vs live.
 */

function _uc_paymentxp_get_customer_id($uid){
  
if (variable_get('uc_paymentxp_txn_mode','') == 'test'){
    $customer_id = md5($uid . "stuff");
  } else {
    $customer_id = $uid;
  }
  return $customer_id;
}

function _uc_paymentxp_customer_vault($order, $payment_type){
  global $user;
  $customer_id = _uc_paymentxp_get_customer_id($order->uid);
  $bank_name = '';
  $account_name = '';
  if ($payment_type == 'credit'){
    if ($order->payment_details['cc_exp_month'] < 10) {
      $expiration_date = '0'. $order->payment_details['cc_exp_month'];
    } else {
      $expiration_date = $order->payment_details['cc_exp_month'];
    }
    //Uh oh. Y2100 bug. hahaha.
    $expiration_date .= substr($order->payment_details['cc_exp_year'], 2, 2);
    $card_number = substr($order->payment_details['cc_number'],0,60);
  } else {
    $bank_name = substr($order->payment_details['paymentxp_bank_name'],0,50);
    $account_name = substr($order->payment_details['paymentxp_bank_acct_name'],0,50);
  }
  //Check if the user is in the vault already:
  $paymentxp_profiles = db_query("SELECT payment_type FROM {uc_payment_paymentxp_profiles} WHERE uid = '%s'",$customer_id);

  while ($record = db_fetch_array($paymentxp_profiles)){
    $payment_types[] = $record['payment_type'];
  }
  //This user has paid before
  if (!empty($payment_types)){
    //They exist, but are using a different payment type. Add it.
    if (!in_array($payment_type, $payment_types)){
      db_query("INSERT INTO {uc_payment_paymentxp_profiles} (pay_id, uid, payment_type, cc_expires) VALUES ('', '%s', '%s', '%s','%s','%s')", $customer_id, $payment_type,$expiration_date,$bank_name,$account_name);
    } else {
      //So credit was in the array, we should update the expiration date just in case they've given us another card.
      if ($payment_type == 'credit'){
        //update the Expiration date..
        db_query("UPDATE {uc_payment_paymentxp_profiles} SET cc_expires = '%s' WHERE uid = '%s' AND payment_type = '%s'", $expiration_date, $customer_id,$payment_type);       
      } else {
        // or update the bank details just in case they gave us new bank info.
        db_query("UPDATE {uc_payment_paymentxp_profiles} SET bank_name = '%s', account_name = '%s' WHERE uid = '%s' AND payment_type = '%s'", $bank_name, $account_name, $customer_id,$payment_type);         
      }
    }
    //Ugly Hack to work around PaymentXP's notion that bank name and account number should be canned if we update the credit card details, so we gotta set em again.
    //This is if we have previously stored ach details for a customer, and now we are storing cc details.
    if (($payment_type == 'credit') && in_array('paymentxp_ach', $payment_types)){
        $bank_details = db_fetch_array(db_query("SELECT bank_name, account_name FROM {uc_payment_paymentxp_profiles} WHERE payment_type = 'paymentxp_ach' and uid = '%s'",$customer_id));
        $bank_name = $bank_details['bank_name'];
        $account_name = $bank_details['account_name'];
    }
    
    $transaction_type = 'UpdateCustomer';
    $operation = 'Updated';
  } else {
    db_query("INSERT INTO {uc_payment_paymentxp_profiles} (pay_id, uid, payment_type, cc_expires) VALUES ('', '%s', '%s','%s')", $customer_id, $payment_type,$expiration_date);
  
    //They exist, but are using a different payment type. Add it.
    $transaction_type = 'AddCustomer';
    $operation = 'Added';
  }  

  $billing_country = uc_get_country_data(array('country_id' => $order->billing_country));
  $delivery_country = uc_get_country_data(array('country_id' => $order->delivery_country));

  $context = array(
    'revision' => 'formatted-original',
    'type' => 'amount',
  );
  $options = array(
    'sign' => FALSE,
    'thou' => FALSE,
    'dec' => '.',
  );
    
  // Build the POST data for the transaction.
  $submit_data = array(
  
    'TransactionType' => $transaction_type,

    // Customer Information
    'CustomerID' => substr($customer_id, 0, 50),
    'CustomerName' => substr($order->billing_first_name . ' ' . $order->billing_last_name, 0, 50),
    'LastName' => substr($order->billing_first_name, 0, 50),
    'FirstName' => substr($order->billing_last_name, 0, 50),
    'Address' => substr($order->billing_street1, 0, 50),
    'City' => substr($order->billing_city, 0, 50),
    'State' => substr(uc_get_zone_code($order->billing_zone), 0, 25),
    'Zip' => substr($order->billing_postal_code, 0, 10),
    'Country' => !$billing_country ? '' : $billing_country[0]['country_name'],
    'Phone' => substr($order->billing_phone, 0, 10),
    'Email' => substr($order->primary_email, 0, 50),
    
    // ACH Details - always have to set these since they'll get deleted if not set
    'BankName' => $bank_name,
    'AccountName' => $account_name,
    // Card Details
    
   );
   if ($payment_type == 'paymentxp_ach'){
    $submit_data['AccountNumber'] = substr($order->payment_details['paymentxp_bank_acct_num'],0,17);
    $submit_data['RoutingNumber'] = substr($order->payment_details['paymentxp_bank_aba_code'],0,9);
    
   } else if ($payment_type == 'credit'){
     $submit_data['CardNumber'] = $card_number;
     $submit_data['CardExpirationDate'] = $expiration_date;
   }
  
  $response = _uc_paymentxp_post_gateway_transaction($submit_data);

  if (variable_get('uc_paymentxp_response_debug', FALSE)) {
    watchdog('uc_paymentxp', 'Debug response: !data', array('!data' => '<pre>'. check_plain(print_r($response, TRUE)) .'</pre>'));
  }

  // If we didn't get an approval response code...
  if ($response['StatusID'] != '1') {
    // Fail the charge with the reason text in the decline message.
    $result = array(
      'success' => FALSE,
      'message' => t('Customer Vault details failed: @message, @status', array('@message' => $response['Message'], '@status' => $response['StatusID'])),
      'uid' => $order->uid,
    );
  }
  else {
    // Build a message for display and comments in the payments table.
    $message = t('PaymentXP CustomerVault: Message: @response<br />Status: @status', array('@response' => $response['Message'], '@status' => $response['StatusID']));
    $result = array(
      'success' => TRUE,
      'comment' => $message,
      'message' => $message,
      'uid' => $order->uid,
    );
  }

  // Build an admin order comment.
  $context = array(
    'revision' => 'formatted-original',
    'type' => 'amount',
  );
  $comment = t('<b>PaymentXP Customer Vault</b><br /><b>Customer @operation @status:</b> @message<br />@statusmsg',
    array('@status' => $result['success'] ? t('Succeeded') : t('Failed'), '@operation' => $operation, '@message' => $response['Message'],  '@statusmsg' => $response['StatusID']));

  // Save the comment to the order.
  uc_order_comment_save($order->order_id, $order->uid, $comment, 'admin');

  return $result; 
}

function _uc_paymentxp_post_gateway_transaction($datafields){

  if (variable_get('uc_paymentxp_txn_mode','') == 'test'){
    $merchant_id = UC_PAYMENTXP_TEST_MERCHANTID;
    $merchant_key = UC_PAYMENTXP_TEST_MERCHANTKEY;
  } else {
    $merchant_id = variable_get('uc_paymentxp_merchant_id', '');
    $merchant_key =  variable_get('uc_paymentxp_merchant_key', '');
  }
  $datafields['MerchantID'] = $merchant_id;
  $datafields['MerchantKey'] = $merchant_key;

  // Translate the data array into a string we can POST.
  $post_fields = array();
  foreach ($datafields as $key => $value) {
    $post_fields[] = $key .'='. urlencode($value);
  }

  // Setup the cURL request.
  $ch = curl_init();
  curl_setopt($ch, CURLOPT_URL, UC_PAYMENTXP_GATEWAY_URL);
  curl_setopt($ch, CURLOPT_VERBOSE, 0);
  curl_setopt($ch, CURLOPT_POST, 1);
  curl_setopt($ch, CURLOPT_POSTFIELDS, implode('&', $post_fields));
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
  curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);
  curl_setopt($ch, CURLOPT_NOPROGRESS, 1);
  curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 0);
  $result = curl_exec($ch);

  // Log any errors to the watchdog.
  if ($error = curl_error($ch)) {
    watchdog('uc_paymentxp', 'cURL error: @error', array('@error' => $error), WATCHDOG_ERROR);
    return t('We encountered a server error while trying to process your payment. Please try again and contact us to complete your order if the problem persists.');
  }
  curl_close($ch);

  $response = explode('&', $result);
  //trim arbitrary blank line on end.
  array_pop($response);
  foreach ($response as $item){
    $parts = explode('=', $item);
    $structured_response[$parts[0]] = $parts[1];
  }

  return $structured_response;
}

// Save the ACH data for an order.
function uc_paymentxp_save_paymentxp_ach($order) {
  // Build the data array for the record in the database.
  $data = $order->payment_details;
  $data['order_id'] = $order->order_id;

  if (empty($data['paymentxp_bank_acct_num_last4'])) {
    $data['paymentxp_bank_acct_num_last4'] = substr($data['paymentxp_bank_acct_num'], -4);
  }

  // Encrypt the routing and account numbers.
  $key = uc_paymentxp_ach_encryption_key();
  $crypt = new uc_encryption_class;

  $data['paymentxp_bank_aba_code'] = $crypt->encrypt($key, base64_encode($data['paymentxp_bank_aba_code'] . md5(time())));
  $data['paymentxp_bank_acct_num'] = $crypt->encrypt($key, base64_encode($data['paymentxp_bank_acct_num'] . md5(time())));

  // Log any errors to the watchdog.
  uc_store_encryption_errors($crypt, 'uc_paymentxp_ach');

  // Check for an existing record.
  $paymentxp_ach_id = db_result(db_query("SELECT paymentxp_ach_id FROM {uc_payment_paymentxp_ach} WHERE order_id = %d", $order->order_id));

  if ($paymentxp_ach_id) {
    $data['paymentxp_ach_id'] = $paymentxp_ach_id;
    $key = 'paymentxp_ach_id';
  }
  else {
    $key = NULL;
  }

  drupal_write_record('uc_payment_paymentxp_ach', $data, $key);
}

// Load the ACH data for an order.
function uc_paymentxp_load_paymentxp_ach($order) {
  $result = db_query("SELECT * FROM {uc_payment_paymentxp_ach} WHERE order_id = %d", $order->order_id);

  if ($data = db_fetch_array($result)) {
    // Decrypt the routing and account numbers.
    $key = uc_paymentxp_ach_encryption_key();
    $crypt = new uc_encryption_class;

    $data['paymentxp_bank_aba_code'] = base64_decode($crypt->decrypt($key, $data['paymentxp_bank_aba_code']));
    $data['paymentxp_bank_aba_code'] = substr($data['paymentxp_bank_aba_code'], 0, strlen($data['paymentxp_bank_aba_code']) - 32);
    $data['paymentxp_bank_acct_num'] = base64_decode($crypt->decrypt($key, $data['paymentxp_bank_acct_num']));
    $data['paymentxp_bank_acct_num'] = substr($data['paymentxp_bank_acct_num'], 0, strlen($data['paymentxp_bank_acct_num']) - 32);

    // Log any errors to the watchdog.
    uc_store_encryption_errors($crypt, 'uc_paymentxp');

    return $data;
  }
  else {
    return array();
  }
}

// Wipe the routing and account numbers from the database for a given order.
function uc_paymentxp_ach_wipe_numbers($order_id) {
  db_query("UPDATE {uc_payment_paymentxp_ach} SET paymentxp_bank_aba_code = '', paymentxp_bank_acct_num = '' WHERE order_id = %d", $order_id);
}

// Return the name of an account type or the entire array of options.
function uc_paymentxp_ach_acct_type($option = NULL) {
  $types = array(
    '1' => t('Checking'),
    //'BUSINESSCHECKING' => t('Business checking'),
    '2' => t('Savings'),
  );

  if (!empty($option) && !empty($types[$option])) {
    return $types[$option];
  }

  return $types;
}

// Allow administrators to process manual ACH payments.
function uc_paymentxp_ach_terminal_form($form_state, $order) {
  $form = array();

  $form['order'] = array(
    '#type' => 'value',
    '#value' => $order,
  );

  $balance = uc_payment_balance($order);

  $form['amount'] = array(
    '#type' => 'textfield',
    '#title' => t('Payment amount'),
    '#description' => t('Order balance: @balance', array('@balance' => uc_currency_format($balance))),
    '#default_value' => $balance > 0 ? uc_currency_format($balance, FALSE, FALSE) : 0,
    '#field_prefix' => variable_get('uc_sign_after_amount', FALSE) ? '' : variable_get('uc_currency_sign', '$'),
    '#field_suffix' => variable_get('uc_sign_after_amount', FALSE) ? variable_get('uc_currency_sign', '$') : '',
    '#required' => TRUE,
    '#size' => 12,
  );

  $form['payment'] = array(
    '#type' => 'fieldset',
    '#title' => t('Payment details'),
    '#tree' => TRUE,
  );

  $form['payment'] += uc_paymentxp_ach_payment_form($form_state, $order);

  // If the ACH data was temporarily saved to the order, clear it now.
  if ($_SESSION['paymentxp_ach_clear']) {
    // Wipe the routing and account numbers from the order.
    uc_paymentxp_ach_wipe_numbers($order->order_id);

    unset($_SESSION['paymentxp_ach_clear']);
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Process payment'),
    '#suffix' => l(t('Cancel'), 'admin/store/orders/'. $order->order_id),
  );

  return $form;
}

function uc_paymentxp_ach_terminal_form_validate($form, &$form_state) {
  if (!is_numeric($form_state['values']['amount']) || $form_state['values']['amount'] <= 0) {
    form_set_error('amount', t('You must enter a positive number for the payment amount.'));
  }
}

function uc_paymentxp_ach_terminal_form_submit($form, &$form_state) {
  $order = $form_state['values']['order'];
  $order->payment_details = $form_state['values']['payment'];

  // Process the ACH payment.
  $result = uc_paymentxp_ach_charge($order, $form_state['values']['amount']);

  // If the payment failed, halt the checkout process.
  if ($result !== TRUE) {
    drupal_set_message($result, 'error');

    uc_order_save($order);

    $_SESSION['paymentxp_ach_clear'] = TRUE;
  }
  else {
    // Otherwise empty out the routing and account numbers.
    uc_paymentxp_ach_wipe_numbers($order->order_id);

    // Update the last 4 digits of the account stored in the database.
    db_query("UPDATE {uc_payment_paymentxp_ach} SET paymentxp_bank_acct_num_last4 = '%s' WHERE order_id = %d", substr($order->payment_details['paymentxp_bank_acct_num'], -4), $order->order_id);

    drupal_set_message(t('ACH Debit payment processed successfully!'));

    $form_state['redirect'] = 'admin/store/orders/'. $order->order_id;
  }
}

function uc_paymentxp_user($op, &$edit){
  global $user;
  switch($op){
    case 'insert':
      $foo='stop the press';
      //If we are adding a user that has a cart_order, then we save em to the vault
      if ($_SESSION['do_complete']){
        $key = uc_credit_encryption_key();
        $crypt = new uc_encryption_class;
        
        $order = uc_order_load($_SESSION['cart_order']);
        $order->uid = $edit['uid'];
        $order->payment_details = unserialize($crypt->decrypt($key, $_SESSION['xpde']));
       
        //TODO- get the right payment type from the order.
        $response = _uc_paymentxp_customer_vault($order, $order->payment_method);

        if (!$response['success']){
          //Saving the profile failed for some reason. Bubble up the exception.

          //TODO: what to do here?
          return $response;
        }
      }
  }
  
}

function uc_paymentxp_cache($payment_details){
      $key = uc_credit_encryption_key();
      $crypt = new uc_encryption_class;
      // Store the encrypted details in the session for the next pageload.
      $_SESSION['xpde'] = $crypt->encrypt($key, serialize($payment_details));
      // Log any errors to the watchdog.
      uc_store_encryption_errors($crypt, 'uc_credit');
  
}

/***********************************************************************/
/*                  Recurring Callback functions                       */
/***********************************************************************/

//
///**
//* Implementation of hook_recurring_info().
//*/
function uc_paymentxp_recurring_info() {
  $items['paymentxp_ach'] = array(
    'name' => t('PaymentXP ACH'),
    'payment method' => 'paymentxp_ach',
    'module' => 'uc_paymentxp',
    'fee handler' => 'paymentxp_ach',
    'renew callback' => 'uc_paymentxp_ach_recurring_renew',
    'process callback' => 'uc_paymentxp_recurring_process',
  
    'saved profile' => TRUE,
  
    'menu' => array(
      //'charge' => UC_RECURRING_MENU_DEFAULT,
      'edit'   => UC_RECURRING_MENU_DEFAULT,
      'update' => array(
        'title' => 'Update Account Details', 
        'page arguments' => array('uc_paymentxp_customer_update_form'),
      ),
      'cancel' => UC_RECURRING_MENU_DEFAULT,
    ), // Use the default user operation defined in uc_recurring.
  );
  
  $items['paymentxp_credit'] = array(
    'name' => t('PaymentXP Credit'),
    'payment method' => 'credit',
    'module' => 'uc_paymentxp',
    'fee handler' => 'paymentxp_credit',
    'renew callback' => 'uc_paymentxp_credit_recurring_renew',
    'process callback' => 'uc_paymentxp_recurring_process',
  
    'saved profile' => TRUE,
    'menu' => array(
      //'charge' => UC_RECURRING_MENU_DEFAULT,
      'edit'   => UC_RECURRING_MENU_DEFAULT,
      'update' => array(
        'title' => 'Update Account Details',
        'page arguments' => array('uc_paymentxp_customer_update_form'),
      ),
      'cancel' => UC_RECURRING_MENU_DEFAULT,
    ), // Use the default user operation defined in uc_recurring.
  );  
  return $items;
}

function uc_paymentxp_recurring_process($order, &$fee){
  
  //We've already saved all the data in the customer gateway, so we'll just let uc_recurring think its all good.
  return TRUE;
}


function uc_paymentxp_ach_recurring_renew($order, &$fee) { 
   
  $result = uc_paymentxp_ach_customer_charge($order, $fee->fee_amount, $op = NULL);
   
    return $result['success'];
}


function uc_paymentxp_credit_recurring_renew($order, &$fee) { 

    $result = uc_paymentxp_credit_customer_charge($order, $fee->fee_amount, $op = NULL);
   
    if ($result['success'] == TRUE) {
      uc_payment_enter($order->order_id, 'credit', $order->order_total, $fee->uid, '', $result['data'], $result['comment']);
      return TRUE;
    }
    
    return $result['success'];
}

function uc_paymentxp_customer_update_form($form_state, $rfid) {
  // Load fee.
  $fee = uc_recurring_fee_user_load($rfid);
  // Load corresponding order.
  $order = uc_order_load($fee->order_id);
  
  drupal_add_js('misc/progress.js');
  
  drupal_add_js(drupal_get_path('module', 'uc_payment') . '/uc_payment.js');
  drupal_add_js(array(
        'defPaymentMsg' => addslashes(variable_get('uc_default_payment_msg', t('Continue with checkout to complete payment.'))),
        'ucURL' => array(
          'checkoutPaymentDetails' => url('cart/checkout/payment_details/'),
        ),
      ), 'setting');
      
      
  $form['rfid'] = array(
    '#type' => 'value',
    '#value' => $rfid,
  );
  $options['paymentxp_ach'] = 'E-Check';
  $options['credit'] = 'Credit Card';
  
  if ($fee->fee_handler == 'paymentxp_credit'){
    $default = 'credit';
  } else {
    $default = 'paymentxp_ach';
    
  }
  
  $details = uc_payment_method_credit_form(array(), $order);
  $details = array_merge($details,uc_paymentxp_ach_payment_form(array(), $order));
      
  $form['payment_method'] = array(
        '#type' => 'radios',
        '#title' => t('Payment method'),
        '#options' => $options,
        '#default_value' => $default,
        '#disabled' => count($options) == 1 ? TRUE : FALSE,
        '#required' => TRUE,
        '#attributes' => array('onclick' => "get_payment_details(Drupal.settings.ucURL.checkoutPaymentDetails + this.value);"),
        '#theme' => 'uc_payment_method_select',
      );
  $form['payment_details']['#value'] = '<div id="payment_details" class="solid-border display-none"></div>';
  
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Update'),
    '#suffix' => l(t('Cancel'), 'user/'. $user->uid),
  );

  return $form;
}
function uc_paymentxp_customer_update_form_submit($form, &$form_state) {
  $fee = uc_recurring_fee_user_load($form_state['values']['rfid']);
  $order = uc_order_load($fee->order_id);
  //Gotta snatch the details from the post..
  $payment_type = $form_state['values']['payment_method'];
   if ($payment_type == 'credit'){
     $fee_handler = 'paymentxp_credit';
     $cc_data = array(
        'cc_type' => check_plain($_POST['cc_type']),
        'cc_owner' => check_plain($_POST['cc_owner']),
        'cc_number' => check_plain(str_replace(' ', '',  $_POST['cc_number'])),
        'cc_start_month' => check_plain($_POST['cc_start_month']),
        'cc_start_year' => check_plain($_POST['cc_start_year']),
        'cc_exp_month' => check_plain($_POST['cc_exp_month']),
        'cc_exp_year' => check_plain($_POST['cc_exp_year']),
        'cc_issue' => check_plain($_POST['cc_issue']),
        'cc_cvv' => check_plain($_POST['cc_cvv']),
        'cc_bank' => check_plain($_POST['cc_bank']),
      );
       
   } else if ($payment_type == 'paymentxp_ach'){
     $fee_handler = 'paymentxp_ach';
     $order->payment_method = $payment_type;
     $data = array(
        'paymentxp_bank_name' => check_plain($_POST['paymentxp_bank_name']),
        'paymentxp_bank_aba_code' => check_plain(str_replace(' ', '',  $_POST['paymentxp_bank_aba_code'])),
        'paymentxp_bank_acct_num' => check_plain(str_replace(' ', '', $_POST['paymentxp_bank_acct_num'])),
        'paymentxp_bank_acct_name' => check_plain($_POST['paymentxp_bank_acct_name']),
        'paymentxp_bank_acct_type' => check_plain($_POST['paymentxp_bank_acct_type']),
      );
     
   }else {
     drupal_set_message(t('An error has occurred while updating your payment details. Please try again and contact us if you are unable to perform the update.'), 'error');
   }
   $order->payment_details = $data;
   //Next update the users details at PaymentXP.
   $response = _uc_paymentxp_customer_vault($order, $payment_type);

  // If the update was successful...
  if ($response['success']) {
    // Save the new fee handler
    if ($fee->fee_handler != $fee_handler){
      $fee->fee_handler = $fee_handler;
      drupal_write_record('uc_recurring_users', $fee, array('rfid'));
    }
    drupal_set_message(t('The payment details for that recurring fee have been updated.'));
  }
  else {
    drupal_set_message(t('An error has occurred while updating your payment details. Please try again and contact us if you are unable to perform the update.'), 'error');
  }

  $form_state['redirect'] = 'user/'. $form_state['values']['uid'];
}





