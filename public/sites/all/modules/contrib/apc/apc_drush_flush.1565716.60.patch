diff --git a/apc.module b/apc.module
index e29c9e0..9c840c9 100644
--- a/apc.module
+++ b/apc.module
@@ -1,4 +1,47 @@
 <?php
+/**
+ * Implements hook_xmlrpc().
+ */
+function apc_xmlrpc() {
+  $methods[] =  array(
+    'apc_drush_flush', // Method name.
+    'apc_drush_flush', // Callback.
+    array(
+      'array', // Return variable.
+      'array', // Input variable.
+    ),
+    t('XMLRPC callback to enable cache clear from Drush/CLI.'), // Description
+  );
+
+  return $methods;
+}
+
+/**
+ * XMLRPC callback to enable cache clear from Drush/CLI.
+ */
+function apc_drush_flush($variables) {
+  $cron_key = isset($variables['cron_key']) ? $variables['cron_key'] : NULL;
+  $bin = isset($variables['bin']) ? $variables['bin'] : NULL;
+  $cid = isset($variables['cid']) ? unserialize($variables['cid']) : NULL;
+  $wildcard = isset($variables['wildcard']) ? $variables['wildcard'] : FALSE;
+
+  if (empty($cron_key) || variable_get('cron_key', 'drupal') != $cron_key) {
+    watchdog('apc', 'APC could not flush cache(s) because an invalid key was used.', array(), WATCHDOG_ERROR);
+    return array(
+      'success' => FALSE,
+      'message' => t('APC could not flush cache(s) because an invalid key was used.'),
+    );
+  }
+  else {
+    $apc = _cache_get_object($bin);
+    $apc->clear($cid, $wildcard == 1);
+
+    return array(
+      'success' => TRUE,
+      'message' => t('APC bin "@bin" flushed', array('@bin' => $bin)),
+    );
+  }
+}
 
 /**
  * Implementation of hook_init().
diff --git a/drupal_apc_cache.inc b/drupal_apc_cache.inc
index 2f7e330..43e0cdf 100644
--- a/drupal_apc_cache.inc
+++ b/drupal_apc_cache.inc
@@ -38,6 +38,11 @@ class DrupalAPCCache implements DrupalCacheInterface {
   protected $prefix;
 
   /**
+   * @var boolean
+   */
+  protected $drush;
+
+  /**
    * Get prefix for bin using the configuration.
    *
    * @param string $bin
@@ -75,6 +80,7 @@ class DrupalAPCCache implements DrupalCacheInterface {
 
   function __construct($bin) {
     $this->bin = $bin;
+    $this->drush = (drupal_is_cli() && function_exists('drush_log'));
 
     // First we determine the prefix from a setting.
     $prefix = self::getPrefixSettingForBin($this->bin);
@@ -255,8 +261,34 @@ class DrupalAPCCache implements DrupalCacheInterface {
   }
 
   function clear($cid = NULL, $wildcard = FALSE) {
-    if (drupal_is_cli() && function_exists('drush_log')) {
-      drush_log($this->bin . '(' . $cid . ') was not cleared. APC cli uses a different memory storage than the webserver. For more info see: http://drupal.org/node/1278232', 'warning');
+    if ($this->drush) {
+      // APC uses separate storage for CLI mode, bounce the clear request back
+      // into this method on all server nodes via XMLRPC.
+      if (!empty($GLOBALS['conf']['apc_nodes'])) {
+        foreach ($GLOBALS['conf']['apc_nodes'] as $apc_node) {
+          $args = array(
+            'apc_drush_flush' => array(array(
+              'bin' => $this->bin,
+              'cid' => serialize($cid),
+              'wildcard' => $wildcard,
+              'cron_key' => variable_get('cron_key', 'drupal'),
+            )),
+          );
+          $uri = $apc_node . '/xmlrpc.php';
+          $response = xmlrpc($uri, $args);
+
+          if ($response === FALSE) {
+            drush_log('xmlrpc() error: (' . xmlrpc_errno() . ') ' . xmlrpc_error_msg(), 'error');
+          }
+          elseif (!$response['success']) {
+            drush_log('APC could not flush cache(s) because ' . $apc_node . ' returned code ' . $response['message'], 'error');
+          }
+          else {
+            // Skip logging
+            //drush_log($response['message'], 'success');
+          }
+        }
+      }
       return;
     }
 
